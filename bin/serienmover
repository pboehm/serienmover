#!/usr/bin/env ruby
# -*- ruby -*-
# encoding: UTF-8

$LOAD_PATH << File.join(File.dirname(__FILE__), '..', 'lib')

require 'serienmover'
require 'serienrenamer'
require 'fileutils'
require 'hashconfig'
require 'optparse'
require 'highline/import'
require "highline/system_extensions"
include HighLine::SystemExtensions

# create program configuration dirs/files
CONFIG_DIR  = File.join( File.expand_path("~"), ".serienmover" )
CONFIG_FILE = File.join( CONFIG_DIR, "config.yml" )
FileUtils.mkdir(CONFIG_DIR) unless File.directory?(CONFIG_DIR)

###
# configuration
STANDARD_CONFIG = {
  :default_directory    => File.join(File.expand_path("~"), "Downloads"),
  :series_directories   => [],
  :read_episode_info    => false,
  :store_path           => '',
  :byte_count_for_md5   => 2048,
  :collective_directory => '',
}

config = STANDARD_CONFIG.merge_with_serialized(CONFIG_FILE)

###
# option definition and handling
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($PROGRAM_NAME)} [DIR]"

  opts.separator("")
  opts.separator("Tool that moves series episodes into a specific")
  opts.separator("directory structure.")
  opts.separator("")
  opts.separator("  Options:")

  opts.on( "-s", "--seriesdir=DIR", String,
           "Directory that contains series data (multiple allowed)") do |dirs|
    dirs = [ dirs ] if dirs.is_a? String

    dirs.each do |d|
      if File.directory?(d)
        config[:series_directories] << d
      end
    end
  end

  opts.on( "-i", "--ignore-seriesinfo",
           "do not use the information from the infostore") do |opt|
    config[:read_episode_info] = false
  end

  opts.on( "-v", "--version",
           "Outputs the version number.") do |opt|
    puts Serienmover::VERSION
    exit
  end

  opts.separator("")
  opts.separator("  Arguments:")
  opts.separator("     DIR      The path that includes the episodes")
  opts.separator("              defaults to ~/Downloads")
  opts.separator("")

end.parse!

###
# change into DIR
episode_directory = ARGV.pop || config[:default_directory]

fail "'#{episode_directory}' does not exist or is not a directory" unless
    Dir.exists?(episode_directory)

Dir.chdir(episode_directory)

###
# instantiate the series_store
store = Serienmover::SeriesStore.new(config[:series_directories])

###
# instantiate information store
info_store = Serienrenamer::InformationStore.new(
    config[:store_path], config[:byte_count_for_md5])

###
# iterate through all episode files
episode_actions = []

Dir.new('.').to_a.sort.each do |file|

  next if file.match(/^\./)
  next unless File.file? file
  next unless Serienrenamer::Episode.determine_video_file(file)

  p file

  episode = Serienrenamer::Episode.new(file)

  # get seriesname from the informationstore which is used by
  # serienrenamer to store the seriesname when it renames files
  md5 = episode.md5sum(config[:byte_count_for_md5])
  series = info_store.episode_hash[md5]

  options = {}
  if config[:read_episode_info] && series && series.match(/\w+/)
    options[:series] = series
  end

  targets = store.find_suitable_target(episode, options)
  selected_target = nil

  ###
  # process the targets
  case targets.size
  when 0
    puts "No suitable target found\n"
    next
  when 1
    selected_target = targets[0]
  else

    begin
      puts "Available targets:"
      choose do |menu|
        menu.prompt = "Choose the right target: "

        targets.each do |t|
          menu.choice t.series do lambda { selected_target = t }.call end
        end
      end
    rescue Interrupt
      puts ""
    end

  end

  if selected_target
    puts ">> '%s'" % selected_target
    episode.target = selected_target

    ###
    # ask for the action (copy/move)
    print "What should be done ( [c]opy (*) , [m]ove ): "
    char = get_character
    print char.chr unless char.chr.match(/\r/)

    unless char.chr.match(/[kcmv\r]/i)
      puts "\nwill be skipped ...\n\n"
      next
    end

    if char.chr.match(/[kc\r]/i)
      episode.set_action(copy: true)
      print " ... copy"
    else
      episode.set_action(move: true)
      print " ... move"
    end

    ###
    # save the episode and set the target as used
    store.set_target_to_used(episode, selected_target)

    episode_actions << episode
  end

  puts "\n\n"
end

exit if episode_actions.empty?

####
# Process the actions on the episodes
print "Start processing the episodes ? [yJ]"
char = get_character
print char.chr

unless char.chr.match(/[jy\r]/i)
  puts "\nwill exit ...\n\n"
  exit
end

puts "\nEpisodes will be processed now"
episode_actions.each do |episode|
  puts "%s '%s' to '%s'" % [episode.action.capitalize, episode, episode.target]

  episode.process_action

  # move copied file into a collective_directory if needed
  if config[:collective_directory] &&
    File.directory?(config[:collective_directory]) &&
      episode.action.match(/copy/i)

    remote_file = File.join(config[:collective_directory],
                            File.basename(episode.episodepath))
    FileUtils.mv(episode.episodepath, remote_file)
  end
end
