#!/usr/bin/env ruby
# -*- ruby -*-
# encoding: UTF-8

$LOAD_PATH << File.join(File.dirname(__FILE__), '..', 'lib')

require 'serienmover'
require 'serienrenamer'
require 'fileutils'
require 'hashconfig'
require 'optparse'
require 'highline/import'
require "highline/system_extensions"
include HighLine::SystemExtensions

# create program configuration dirs/files
CONFIG_DIR  = File.join( File.expand_path("~"), ".serienmover" )
CONFIG_FILE = File.join( CONFIG_DIR, "config.yml" )
FileUtils.mkdir(CONFIG_DIR) unless File.directory?(CONFIG_DIR)

###
# configuration
STANDARD_CONFIG = {
  :default_directory      => File.join(File.expand_path("~"), "Downloads"),
  :series_directories     => [],
  :read_episode_info      => false,
  :store_path             => '',
  :byte_count_for_md5     => 2048,
  :post_copy_hook         => '',
  :auto_process_list      => false,
  :auto_process_list_file => File.join(CONFIG_DIR, "autoprocess.yml")
}

config = STANDARD_CONFIG.merge_with_serialized(CONFIG_FILE)

###
# option definition and handling
options = {}
OptionParser.new do |opts|
  opts.banner = "Usage: #{File.basename($PROGRAM_NAME)} [DIR]"

  opts.separator("")
  opts.separator("Tool that moves series episodes into a specific")
  opts.separator("directory structure.")
  opts.separator("")
  opts.separator("  Options:")

  opts.on( "-s", "--seriesdir=DIR", String,
           "Directory that contains series data (multiple allowed)") do |dirs|
    dirs = [ dirs ] if dirs.is_a? String

    dirs.each do |d|
      if File.directory?(d)
        config[:series_directories] << d
      end
    end
  end

  opts.on( "-i", "--ignore-seriesinfo",
           "do not use the information from the infostore") do |opt|
    config[:read_episode_info] = false
  end

  opts.on( "-n", "--[no]-autoprocess",
           "use a file to select between copying and moving") do |opt|
    config[:auto_process_list] = opt
  end

  opts.on( "-v", "--version",
           "Outputs the version number.") do |opt|
    puts Serienmover::VERSION
    exit
  end

  opts.separator("")
  opts.separator("  Arguments:")
  opts.separator("     DIR      The path that includes the episodes")
  opts.separator("              defaults to ~/Downloads")
  opts.separator("")

end.parse!

###
# change into DIR
episode_directory = ARGV.pop || config[:default_directory]

fail "'#{episode_directory}' does not exist or is not a directory" unless
    Dir.exists?(episode_directory)

Dir.chdir(episode_directory)

###
# instantiate the series_store
store = Serienmover::SeriesStore.new(config[:series_directories])

###
# build up and load autoprocess list
autoprocess_list = {}

if config[:auto_process_list] && config[:auto_process_list] == true
  exisiting_series = Hash[store.series_list.map{ |s| [s, "n"] }]
  autoprocess_list =
    exisiting_series.merge_with_serialized(config[:auto_process_list_file])
end

###
# instantiate information store
info_store = Serienrenamer::InformationStore.new(
    config[:store_path], config[:byte_count_for_md5])

###
# iterate through all episode files
episode_actions = []

Dir.new('.').to_a.sort.each do |file|

  next if file.match(/^\./)
  next unless File.file? file
  next unless Serienrenamer::Episode.determine_video_file(file)

  p file

  episode = Serienrenamer::Episode.new(file)

  # get seriesname from the informationstore which is used by
  # serienrenamer to store the seriesname when it renames files
  md5 = episode.md5sum(config[:byte_count_for_md5])
  series = info_store.episode_hash[md5]

  options = {}
  if config[:read_episode_info] && series && series.match(/\w+/)
    options[:series] = series
  end

  targets = store.find_suitable_target(episode, options)
  selected_target = nil

  ###
  # process the targets
  case targets.size
  when 0
    puts "No suitable target found\n"
    next
  when 1
    selected_target = targets[0]
  else

    begin
      puts "Available targets:"
      choose do |menu|
        menu.prompt = "Choose the right target: "

        targets.each do |t|
          menu.choice t.series do lambda { selected_target = t }.call end
        end
      end
    rescue Interrupt
      puts ""
    end

  end

  if selected_target
    puts ">> '%s'" % selected_target
    episode.target = selected_target

    # get the choice from the autoprocess
    choice = autoprocess_list[episode.target.series]
    copy = nil
    copy = true if choice && choice.match(/[ck]/i)
    copy = false if choice && choice.match(/[vm]/i)

    ###
    # ask for the action (copy/move)
    print "What should be done ( [c]opy (*) , [m]ove ): "
    char = nil

    if copy.nil?
      char = get_character
      print char.chr unless char.chr.match(/\r/)

      unless char.chr.match(/[kcmv\r]/i)
        puts "\nwill be skipped ...\n\n"
        next
      end
    end

    if copy == true || char && char.chr.match(/[kc\r]/i)
      episode.set_action(copy: true)
      print " ... copy"
    else
      episode.set_action(move: true)
      print " ... move"
    end

    ###
    # save the episode and set the target as used
    store.set_target_to_used(episode, selected_target)

    episode_actions << episode
  end

  puts "\n\n"
end

exit if episode_actions.empty?

####
# Process the actions on the episodes
print "Start processing the episodes ? [yJ]"
char = get_character
print char.chr

unless char.chr.match(/[jy\r]/i)
  puts "\nwill exit ...\n\n"
  exit
end

puts "\nEpisodes will be processed now"
episode_actions.each do |episode|
  puts "%s '%s' to '%s'" % [episode.action.capitalize, episode, episode.target]

  episode.process_action

  ###
  # run the Script that is supplied in config[:post_copy_hook]
  # this lets you process episodes that are copied
  #
  # the supplied Script is called with two parameters
  #     1. the path to the episodefile
  #     2. the seriesname
  if config[:post_copy_hook] &&
    File.file?(config[:post_copy_hook]) &&
        File.executable?(config[:post_copy_hook]) &&
            episode.action.match(/copy/i)

    puts "Calling Post-Copy-Hook for this episode"
    cmd = '%s "%s" "%s"' %
        [ config[:post_copy_hook], episode.episodepath, episode.target ]

    system(cmd) or fail "Post-Copy-Hook ends not succesfully"
  end
end
